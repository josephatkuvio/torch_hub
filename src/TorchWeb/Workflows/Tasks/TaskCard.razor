<article class="@(isExpanded ? "expanded" : "")">
    <header>
        <h2>@((Task.SortOrder ?? 0).ToString("00"))</h2>
        @if (isExpanded)
        {
            <button class="order" @onclick="MoveUp" @onclick:stopPropagation=true>
                <img class="detail-icon-img" src="/images/up.svg" />
            </button>
            <button @onclick="MoveDown" @onclick:stopPropagation=true>
                <img class="detail-icon-img" src="/images/down.svg" />
            </button>
        }
    </header>

    <div>
        <header @onclick="ToggleExpandCollapse">
            <h2>@Task.Name</h2>
            <div class="right-btns">
                @*<button class="tiny" @onclick:stopPropagation=true>
                    <img src="/images/close_icon.svg" />
                </button>
                <button class="tiny" @onclick:stopPropagation=true>
                    <img src="/images/greenEditSaveIcon.svg" />
                </button>*@
                <button class="tiny" @onclick=Delete @onclick:stopPropagation=true>
                    <img src="/images/Trashcan.svg" />
                </button>
            </div>
            @if (isExpanded)
            {
                <h3>@Task.Description</h3>
            }
        </header>

        @if (isExpanded)
        {
            <footer>
                @foreach (var key in Task.Parameters.Keys)
                {
                    <label>
                        @key
                        <input @bind="@Task.Parameters[key]" @bind:after=Save />
                    </label>
                }
            </footer>
        }
    </div>
</article>

@inject IRepository<TorchTask> Tasks
@code {
    [Parameter] public TorchTask Task { get; set; } = null!;
    [Parameter] public EventCallback<TorchTask> OnDelete { get; set; }
    [Parameter] public EventCallback<TorchTask> OnReorder { get; set; }
    private bool isExpanded = true;
    

    private void ToggleExpandCollapse()
    {
        isExpanded = !isExpanded;
    }

    async Task MoveUp()
    {
        Task.SetSortOrder(true);
        await OnReorder.InvokeAsync(Task);
    }

    async Task MoveDown()
    {
        Task.SetSortOrder(false);
        await OnReorder.InvokeAsync(Task);
    }

    async Task Save() => await Tasks.UpdateAsync(Task);
    async Task Delete() => await OnDelete.InvokeAsync(Task);
}